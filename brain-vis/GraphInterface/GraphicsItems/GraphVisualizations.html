<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>CSE collaborations</title>
    <style>
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            border: 5px;
        }
        .note{
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>

<body>
<script src="../js/d3.min.js"></script>
<script>
var maxRadius = 12;
var padding = 1.5; // separation between same-color nodes
var clusterPadding = 6; // separation between different-color nodes


var width = 960,
        height = 960,
        innerRadius = Math.min(width, height) * .41,
        outerRadius = innerRadius * 1.02;

var r = 22;

var color = d3.scale.category10();
var area ={
    AI:1,
    DB:2,
    NE:3,
    ST:4,
    TH:5,
    VG:6,
    Unknow:7,
    "":7
};

var areaNames =[
    "AI",
    "DB",
    "NE",
    "ST",
    "TH",
    "VG",
    "Unknown"
];

var fullName = {
    "AI" : "Artificial Intelligence",
    "DB" : "Database",
    "NE" : "Networking and Computer Systems",
    "ST" : "Software Technologies",
    "TH" : "Theoretical Computer Science",
    "VG" : "Vision and Graphics",
    "Unknown" : "Unknown"
}

var areaArr =["AI","DB","NE","ST","TH","VG","Unknown"];

var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);



var areaBoxes = svg.selectAll(".label")
        .data(areaArr)
        .enter()
        .append("g")
        .attr("class","label");
var note = d3.select("body").append("text")
        .attr("class","note")
        .style("width","300px")
        .style("position","absolute")
        .style("left",width - 300+"px")
        .style("top","10px")
        .style("font-size", "13px")
        .style("font-family","Serif")
        .style("opacity",0.2)
    //.text("Note: If someone is selected, the digit belows selected professor " +
    //        "indicates the number of collaborations with others and the digits " +
    //        "below other professors indicate the collaboration with him or her." +
    //        "If no one is selected, the digit indicate the total collaboration times with others.")
        .text("Note: The node label indicates the number of co-authored publications.")
        .on("mouseover",function(){
            this.style.opacity = 1;
        }).
        on("mouseout",function(){
            this.style.opacity = 0.2;
        })


areaRects = areaBoxes.append("rect")
        .attr("x",40)
        .attr("y",function(d,index){
            return 20+index*30;
        })
        .attr("width",20)
        .attr("height",20)
        .attr("fill",function(d){
            if(d == "Unknown") return "#999";
            return color(area[d]);
        })
        .attr("opacity",0.4);

areaText = areaBoxes.append("text")
        .text(function(d){
            return fullName[d];
        })
        .attr("x",function(d,index){
            return 80;
        })
        .attr("y",function(d,index){
            return 35+index*30;
        });

svg = svg
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

d3.json("../data/cse.json", function(error, graph) {
    var len = 7;
    var areaMatrix = new Array(len);
    for (var i = 0; i < len; i++) {
        areaMatrix[i] = new Array(len);
        for (var j = 0; j < len; j++) {
            areaMatrix[i][j] = 0;
        }
    }

    for (var i = 0; i < graph.nodes.length; i++) {
        var nodeArea = graph.nodes[i].area;

        var nodeAreaID = area[nodeArea];
        if(nodeAreaID == undefined)
            nodeAreaID = 7;
        nodeAreaID = nodeAreaID - 1;

        areaMatrix[nodeAreaID][nodeAreaID] = areaMatrix[nodeAreaID][nodeAreaID] + 1;
    }

//    for (var i = 0; i < graph.links.length; i++) {
//        var source = graph.links[i].source;
//        var target = graph.links[i].target;
//        var weight = parseInt(graph.links[i].weight);
//
//        var sourceArea = graph.nodes[source].area;
//        var targetArea = graph.nodes[target].area;
//
//        var sourceAreaID = area[sourceArea]-1;
//        var targetAreaID = area[targetArea]-1;
//
//        areaMatrix[sourceAreaID][targetAreaID] = areaMatrix[sourceAreaID][targetAreaID] + weight;
//        areaMatrix[targetAreaID][sourceAreaID] = areaMatrix[sourceAreaID][targetAreaID];
//    }

    var areaChord = d3.layout.chord()
        //                .padding(0.2)
        //                .sortGroups(d3.descending)
            .sortSubgroups(d3.descending)
            .matrix(areaMatrix);

    var are_chord = svg.append("g")
            .selectAll("path")
            .data(areaChord.groups)
            .enter().append("path")
            .attr("class", "areaChord")
            .style("fill", function (d) {
                if(d.index == 6) return "#999";
                return color(d.index+1);
            })
            .style("stroke", function (d) {
                if(d.index == 6) return "#999";
                return color(d.index+1);
            })
            .style("opacity", 0.4)
            .attr("d", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius * 1.05))
            .on("mouseover",function(data){
                this.style.opacity = 1;

                areaRects.style("opacity",function(d){
                    if(d == areaNames[data.index]){
                        return 1;
                    }else if(d == "Unknown" && areaNames[data.index] == "Unknown"){
                        return 1;
                    }
                    else{
                        return 0.4;
                    }
                })

                nodes.style("opacity",function(d){
                    if(areaNames[data.index] == d.area){
                        return 0.8;
                    }else if(areaNames[data.index] == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                        return 0.8;
                    }else{
                        return 0.1;
                    }
                })
                pic.style("opacity",function(d){
                    if(areaNames[data.index] == d.area){
                        return 1;
                    }else if(areaNames[data.index] == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                        return 1;
                    }else{
                        return 0.1;
                    }
                })
                textLabel.style("opacity",function(d){
                    if(areaNames[data.index] == d.area){
                        return 1;
                    }else if(areaNames[data.index] == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                        return 1;
                    }else{
                        return 0.1;
                    }
                });
                link.style("opacity",function(d){

                    if(d.source.area == areaNames[data.index] && d.target.area == areaNames[data.index]){
                        return 1;
                    }else{
                        return 0.1;
                    }
                })
            })
            .on("mouseout",function(data){
                areaRects.style("opacity", 0.4);
                are_chord.style("opacity", 0.4);
                nodes.style("opacity",0.4);
                pic.style("opacity",1);
                textLabel.text(function(data){
                    return data.total;
                })
                        .style("opacity",1);
                link.style("opacity",0.4);

            });



    var prof_centerNodes = [];
    var prof_groups = areaChord.groups();
    for (var i = 0; i < prof_groups.length; i++) {
        var d = prof_groups[i];
        var x = innerRadius * 0.6 * Math.sin((d.endAngle + d.startAngle) / 2);
        var y = -innerRadius * 0.6 * Math.cos((d.endAngle + d.startAngle) / 2);
        var areaName = areaNames[i];
        prof_centerNodes.push({x: x, y: y, a: areaName});
    }
    prof_centerNodes.aiMap = {};
    for (var i = 0; i < prof_centerNodes.length; i++) {
        prof_centerNodes.aiMap[prof_centerNodes[i].a] = i;
    }

    prof_centerNodes.getProfCenterNodes = function (areaName) {
        var index = this.aiMap[areaName];
        if(index == undefined) index = 6;

        return prof_centerNodes[index];
    };


    for(var i=0;i<graph.nodes.length;i++){
        graph.nodes[i].neighbor =[];
    }

    var force = d3.layout.force()
            .nodes(graph.nodes)
            .links(graph.links)
            .charge(-1200)
            .chargeDistance(300)
            .linkDistance(50)
            .gravity(0)
            .linkStrength(0.3)
            .size([width, height])
            .start();

    for(var i=0;i<graph.links.length;i++){
        var l = graph.links[i];
        l.source.neighbor.push(l.target);
        l.target.neighbor.push(l.source);

    }

    var link = svg.selectAll(".link")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width",function(data){
                return Math.sqrt(data.num);
            })
            .style("stroke","#999")
            .style("stroke-opacity",".6")
            .style("stroke-width", function(d) { return Math.sqrt(d.weight); });
    var g = svg.selectAll(".node")
            .data(graph.nodes)
            .enter()
            .append("g");
    var nodes = g.append("circle")
            .attr("r",24)
            .attr("class","node")
            .style("fill",function(d){
                if(area[d.area]==undefined || area[d.area]==7){
                    return "#999";
                }
                return color(area[d.area]);
            })
            .style("opacity",0.4)
            .call(force.drag);

    var pic = g.append("image")
            .attr("xlink:href", function(d){
                return "img/"+ d.url;
            })
            .attr("x", "-17")
            .attr("y", "-17")
            .attr("width", "34")
            .attr("height", "34")
            .attr("style", "border:5px;")
            .on("mouseover",function(data,index){
                areaRects.style("opacity",function(d){
                    if(d == data.area){
                        return 1;
                    }else if(d == "Unknown" && (area[data.area] == undefined || area[data.area] == 6)){
                        return 1;
                    }
                    else{
                        return 0.4;
                    }
                })

                are_chord.style("opacity",function(d){
                    if(areaNames[d.index] == data.area){
                        return 1;
                    }else if(areaNames[d.index] == "Unknown" && (area[data.area] == undefined || area[data.area] == 7)){
                        return 1;
                    }
                    else{
                        return 0.4;
                    }
                })

                nodes[0][index].style.opacity = 0.8;
                nodes[0].forEach(function(n,i){
                    if(n.__data__.collaMap[index]){
                        nodes[0][i].style.opacity = 0.8;
                    }
                    else if(i!=index){
                        nodes[0][i].style.opacity = 0.1;
                        pic[0][i].style.opacity = 0.3;
                    }
                });
                textLabel.attr("x",function(data){return data.x-4;})
                        .attr("y",function(data){return data.y+40;})
                        .text(function(data,id){
                            if(data.collaMap[index]){
                                return data.collaMap[index];
                            }
                            else if(id == index){
                                return data.collaboration;
                            }
                            else
                            {
                                return "";
                            }
                        })
                link.style("opacity",function(d){
                    if(d.source.label == data.label|| d.target.label == data.label){
                        return 1;
                    }else{
                        return  0.1;
                    }
                })
            })
            .on("mouseout",function(){
                are_chord.style("opacity", 0.4);
                nodes.style("opacity",0.4);
                pic.style("opacity",1);
                textLabel.text(function(data){
                    return data.total;
                });
                link.style("opacity",0.4);
                areaRects.style("opacity",0.4);

            })
            .call(force.drag);

    pic.append("title")
            .text(function(d) { return d.name+'\n'+
                    "Research area："+d.area+'\n'; });
    link.append("title")
            .text(function(d) {return d.weight;});
    var textLabel = svg.append("g")
            .selectAll(".text")
            .data(graph.nodes)
            .enter()
            .append("text")
            .attr("class","text")
            .style("font-size", "13px")
            .style("font-family","Serif")
            .text(function(data){
                return data.total;
            })
            .attr("x",function(data){return data.x-4;})
            .attr("y",function(data){return data.y+35;})

    force.on("tick", function(e) {

        var k = e.alpha*0.8 ;
        // Push nodes toward their designated focus.
        graph.nodes.forEach(function (o, i) {
            var cx = prof_centerNodes.getProfCenterNodes(o.area).x;
            var cy = prof_centerNodes.getProfCenterNodes(o.area).y;
            o.x += (cx - o.x) * k;
            o.y += (cy - o.y) * k;
        });

        link.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

        nodes.attr("cx", function(d) { return d.x;  })
                .attr("cy", function(d) { return d.y; })

        pic.attr("transform", function(d)
                {
                    return "translate(" + d.x + "," + d.y + ")"; }
        );
        textLabel.attr("x",function(data){return data.x-4;})
                .attr("y",function(data){return data.y+35;})

    });
    areaRects.on("mouseover",function(data){
        this.style.opacity = 1;
        are_chord.style("opacity",function(d){
            if(areaNames[d.index] == data){
                return 1;
            }else if(areaNames[d.index] == "Unknown" && data == "Unknown"){
                return 1;
            }
            else{
                return 0.4;
            }
        })
        nodes.style("opacity",function(d){
            if(data == d.area){
                return 0.8;
            }else if(data == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                return 0.8;
            }else{
                return 0.1;
            }
        })
        pic.style("opacity",function(d){
            if(data == d.area){
                return 1;
            }else if(data == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                return 1;
            }else{
                return 0.1;
            }
        })
        textLabel.style("opacity",function(d){
            if(data == d.area){
                return 1;
            }else if(data == "Unknown" && (area[d.area] == undefined || area[d.area] == 7)){
                return 1;
            }else{
                return 0.1;
            }
        });
        link.style("opacity",function(d){

            if(d.source.area == data && d.target.area == data){
                return 1;
            }else{
                return 0.1;
            }
        })
    });
    areaRects.on("mouseout",function(data){
        areaRects.style("opacity", 0.4);
        are_chord.style("opacity", 0.4);
        nodes.style("opacity",0.4);
        pic.style("opacity",1);
        textLabel.text(function(data){
            return data.total;
        })
                .style("opacity",1);
        link.style("opacity",0.4);

    });

});

</script>
</body>
</html>